# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AYQJCCtnOUWMhydLqAeEi2231WcPXZel
"""



"""# 4.1 선형 회귀"""

import matplotlib.pyplot as plt

population_inc = [0.3, -0.78, 1.26, 0.03, 1.11, 15.17, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
population_inc = population_inc[:5] + population_inc[6:]
population_old = [12.27, 14.44, 11.87, 18.75, 17.52, 9.29, 16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]
population_old = population_old[:5] + population_old[6:]
plt.plot(population_inc, population_old,'bo')
plt.xlabel('Growth')
plt.ylabel('Old')

plt.show()

"""최소제곱법을 이용한 선형회귀"""

import matplotlib.pyplot as plt
import numpy as np

X = [0.3, -0.78, 1.26, 0.03, 1.11, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
Y = [12.27, 14.44, 11.87, 18.75, 17.52,  16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]

#X와 Y의 평균 계산
x_bar = sum(X)/len(X)
y_bar = sum(Y)/len(Y)

#최소제곱법을 이용해서 a,b를 찾는다

a = sum([(y-y_bar)*(x-x_bar) for y,x in list(zip(Y,X))])
a /= sum([(x-x_bar)**2 for x in X])
b = y_bar - a*x_bar

print(a,b)

#그래프를 구하기 위한 회귀선의 x,y데이터 구하기
line_x = np.arange(min(X),max(X), 0.01)
line_y = a * line_x +b
print(line_x)
plt.plot(line_x,line_y,'r-')

plt.plot(X,Y,'bo')

plt.show()

"""최소제곱법 대신 tensorflow를 이용한 선형 회귀"""

# Commented out IPython magic to ensure Python compatibility.
try : 
#   %tensorflow_version 2.x
except Exception:
  pass
import tensorflow as tf

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import random

X = [0.3, -0.78, 1.26, 0.03, 1.11, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
Y = [12.27, 14.44, 11.87, 18.75, 17.52,  16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]
#a와 b random initialization
a = tf.Variable(random.random())
b = tf.Variable(random.random())

def compute_loss():
  y_pred = a*X + b
  loss = tf.reduce_mean((Y-y_pred)**2)
  return loss

print(tf.__version__)
optimizer = tf.optimizers.Adam(lr=0.07)
for i in range(1000):
  optimizer.minimize(compute_loss, var_list=[a,b])

  if i % 100 == 99:
    print(i,a.numpy(),b.numpy(), compute_loss().numpy())

line_x = np.arange(min(X),max(X),0.01)
line_y = a * line_x + b

plt.plot(line_x,line_y,'r-')
plt.plot(X,Y,'bo')
plt.show()

"""# 4.2 다항 회귀"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import random
import math

X = [0.3, -0.78, 1.26, 0.03, 1.11, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
Y = [12.27, 14.44, 11.87, 18.75, 17.52,  16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]
#a와 b random initialization
a = tf.Variable(random.random())
b = tf.Variable(random.random())
c = tf.Variable(random.random())

def compute_loss():
  y_pred = a * X ** 2 + b * X + c
  loss = tf.reduce_mean((Y-y_pred)**2)
  return loss

print(tf.__version__)
optimizer = tf.optimizers.Adam(lr=0.07)
for i in range(1000):
  optimizer.minimize(compute_loss, var_list=[a,b,c])

  if i % 100 == 99:
    print(i,a.numpy(),b.numpy(), c.numpy(), compute_loss().numpy())

line_x = np.arange(min(X),max(X),0.01)
line_y = a * line_x **2  + b * line_x + c

plt.plot(line_x,line_y,'r-')
plt.plot(X,Y,'bo')
plt.show()

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import random
import math

X = [0.3, -0.78, 1.26, 0.03, 1.11, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
Y = [12.27, 14.44, 11.87, 18.75, 17.52,  16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]
#a와 b random initialization

a = tf.Variable(random.random())
b = tf.Variable(random.random())
c = tf.Variable(random.random())
d = tf.Variable(random.random())

def compute_loss():
  y_pred = a * X**3 + b * X**2 + c * X + d
  loss = tf.reduce_mean((Y-y_pred)**2)
  return loss

print(tf.__version__)
optimizer = tf.optimizers.Adam(lr=0.07)
for i in range(1000):
  optimizer.minimize(compute_loss, var_list=[a,b,c,d])

  if i % 100 == 99:
    print(i,a.numpy(),b.numpy(), c.numpy(), d.numpy(), compute_loss().numpy())

line_x = np.arange(min(X),max(X),0.01)
line_y = a * line_x**3  + b * line_x**2 + c* line_x+ d

plt.plot(line_x,line_y,'r-')
plt.plot(X,Y,'bo')
plt.show()

"""# 4.3 딥러닝 네트워크를 이용한 회귀"""

import tensorflow as tf
import numpy as np
X = [0.3, -0.78, 1.26, 0.03, 1.11, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
Y = [12.27, 14.44, 11.87, 18.75, 17.52,  16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]

model = tf.keras.Sequential([
      tf.keras.layers.Dense(units = 6, activation='tanh', input_shape=(1,)),
      tf.keras.layers.Dense(units=1)
])

model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),loss='mse')

model.summary()

model.fit(X,Y,epochs = 10)

model.predict(X)

import tensorflow as tf
import matplotlib.pyplot as plt
import numpy as np
X = [0.3, -0.78, 1.26, 0.03, 1.11, 0.24, -0.24, -0.47, -0.77, -0.37, -0.85, -0.41, -0.27, 0.02 , -0.76, 2.66]
Y = [12.27, 14.44, 11.87, 18.75, 17.52,  16.37, 19.78,19.51, 12.65, 14.74, 10.72, 21.94, 12.83, 15.51, 17.14, 14.42]

model = tf.keras.Sequential([
      tf.keras.layers.Dense(units = 6, activation='tanh', input_shape=(1,)),
      tf.keras.layers.Dense(units=1)
])

model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),loss='mse')

model.summary()

model.fit(X,Y,epochs = 10)

line_x = np.arange(min(X),max(X), 0.01)
line_y = model.predict(line_x)

plt.plot(line_x,line_y,'r-')
plt.plot(X,Y,'bo')

plt.show()

"""# 4.4 보스턴 주택 가격 데이터세트"""

import matplotlib.pyplot as plt

from tensorflow.keras.datasets import boston_housing
(train_X, train_Y), (test_X, test_Y) = boston_housing.load_data()

print(len(train_X), len(test_X))
print(train_X[0])
print(train_Y[0])

x_mean = train_X.mean()
x_std = train_X.std()
train_X -= x_mean
train_X /= x_std
test_X -= x_mean
test_X /= x_std

y_mean = train_Y.mean()
y_std = train_Y.std()
train_Y -= y_mean
train_Y /= y_std
test_Y -= y_mean
test_Y /= y_std

print(train_X[0])
print(train_Y[0])

model= tf.keras.Sequential([
      tf.keras.layers.Dense(units=52, activation='relu',input_shape=(13,)),
      tf.keras.layers.Dense(units=39, activation='relu'),
      tf.keras.layers.Dense(units=26, activation='relu'),
      tf.keras.layers.Dense(units=1),
])

model.compile(optimizer=tf.keras.optimizers.Adam(lr=0.07),loss='mse')

model.summary()

history = model.fit(train_X,train_Y,epochs=25,batch_size=32,validation_split=0.25)
#plt.plot(history.history['loss'],'b-',label='loss')
#plt.plot(history.history['val_loss'],'r--',label='val_loss')
#plt.xlabel("epochs")
#plt.legend()

pred_Y = model.predict(test_X)

plt.figure(figsize=(5,5))
plt.plot(test_Y,pred_Y,'b.')
plt.axis([min(test_Y),max(test_Y),min(test_Y),max(test_Y)])

plt.plot([min(test_Y),max(test_Y)],[min(test_Y),max(test_Y)],ls='--',c='.3')
plt.show()

model.evaluate(test_X,test_Y)

import matplotlib.pyplot as plt

from tensorflow.keras.datasets import boston_housing
(train_X, train_Y), (test_X, test_Y) = boston_housing.load_data()

print(len(train_X), len(test_X))
print(train_X[0])
print(train_Y[0])

x_mean = train_X.mean()
x_std = train_X.std()
train_X -= x_mean
train_X /= x_std
test_X -= x_mean
test_X /= x_std

y_mean = train_Y.mean()
y_std = train_Y.std()
train_Y -= y_mean
train_Y /= y_std
test_Y -= y_mean
test_Y /= y_std

print(train_X[0])
print(train_Y[0])

model= tf.keras.Sequential([
      tf.keras.layers.Dense(units=52, activation='relu',input_shape=(13,)),
      tf.keras.layers.Dense(units=39, activation='relu'),
      tf.keras.layers.Dense(units=26, activation='relu'),
      tf.keras.layers.Dense(units=1),
])

model.compile(optimizer=tf.keras.optimizers.Adam(lr=0.07),loss='mse')

model.summary()

history = model.fit(train_X,train_Y,epochs=25,batch_size=32,validation_split=0.25,
                    callbacks=[tf.keras.callbacks.EarlyStopping(patience=3,monitor='val_loss')])

plt.plot(history.history['loss'],'b-',label='loss')
plt.plot(history.history['val_loss'],'r--',label='val_loss')
plt.xlabel("epochs")
plt.legend()
plt.show()

pred_Y = model.predict(test_X)

plt.figure(figsize=(5,5))
plt.plot(test_Y,pred_Y,'b.')
plt.axis([min(test_Y),max(test_Y),min(test_Y),max(test_Y)])

plt.plot([min(test_Y),max(test_Y)],[min(test_Y),max(test_Y)],ls='--',c='.3')
plt.show()

model.evaluate(test_X,test_Y)

